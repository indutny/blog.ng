<!DOCTYPE html>
<html>
  <head>
    <meta name=viewport content"width=device-width,initial-scale=1,maximum-scale=10" />
    
    <title>Allocating numbers</title>
    
    <link rel=alternate type="application/rss+xml" href="http://darksi.de/rss.xml" title="Fedor Indutny's blog">
    <link rel=stylesheet href="/css/main.css" />
  </head>
  <body>
    <aside id=info>
      <section class=info-title>
        <a href="/">darksi.de</a>
        <br/>
        of
        </br>
        Software Engineering
      </section>
    
      <section class=info-copyright>
        Copyright <a href="https://github.com/indutny">Fedor Indutny</a>,
        view <a href="http://opensource.org/licenses/mit-license.php">license</a>
      </section>
    
      <section class=info-credits>
        <i>Icons by: Bluetip Design from the Noun Project</i>
      </section>
    </aside>
    <section id=content>
      <article class=post>
        <section class=post-header>
          <button class=votewdgt title=upvote>?</button>
          <h1>Allocating numbers</h1>
          <span class=post-header-date>Tue Nov 05 2013 19:00:00 GMT-0500 (Eastern Standard Time)</span>
        </section>

        <section class=post-body>
          <h2 id="jit">JIT</h2>
<p>This is the second blog post in the series about JIT compiling.
<a href="/4.how-to-start-jitting">The previous post</a> was an introduction into the Just-In-Time code
generation and, in particular, <a href="https://github.com/indutny/jit.js">jit.js</a> usage. If you haven&#39;t read it yet -
I recommend you to familiarize yourself with <a href="/4.how-to-start-jitting">it</a> first.</p>
<h2 id="objectives">Objectives</h2>
<p>Previously, we created a JIT compiler, supporting a very limited subset of
JavaScript: integer numbers, math binary operators (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>), and
<code>-</code> unary operator. This time, we will extend it by adding floating point
number support, and, to make the process funnier and to spice things up,
we will allocate and store these numbers in the heap.</p>
<p>Though, because we are doing things one step at a time, our heap won&#39;t have
Garbage Collection, and will live inside fixed sized memory chunk (say &quot;yay&quot; to
simplicity!).</p>
<h2 id="stubs">Stubs</h2>
<p>Knowing what we aim to do, we can now set up internal structures for these
features. Essentially, what we&#39;ll need is a memory allocation procedure, that
generates and returns memory addresses suitable for our goals.</p>
<p>This allocation code could be generated for every AST node using series of
inlined assembly instructions, which works great and, more importantly, is
incredibly fast for concise operations. But due to the relatively big code&#39;s
size of this procedure, the resulting machine code output may become too big to
be fit entirely into the CPU&#39;s cache, causing potential performance problems to
the whole system.</p>
<p>Generally, this is considered a bad practice. A better approach would be
parameterizing such code blocks into shared procedures called <code>stubs</code> (I picked
that naming from <a href="https://github.com/v8/v8/blob/master/src/ia32/code-stubs-ia32.cc">v8&#39;s source</a> and, perhaps, it is how these things are
named in other VMs too). For even better optimization these procedures
could be lazily compiled, i.e. we should not compile those ones that are not
used by generated code. This technique is good for both compilation time and
executable code size (and therefore CPU caches too).</p>
<p>Fortunately, <a href="https://github.com/indutny/jit.js">jit.js</a> lets you generate <em>stubs</em> easily:</p>
<pre><code class="lang-javascript">var stubs = jit.stubs();

stubs.define(&#39;Allocate&#39;, function() {
  // Our code here
  // ....

  // Returning back to caller
  this.Return();
});
</code></pre>
<p>Simple, isn&#39;t it? Now, to use it in our JIT compiler we&#39;ll need to pass it in
an options argument:</p>
<pre><code class="lang-javascript">jit.compile(function() {
  // Compiler code generation happens in this context

  // Explanation:
  // Read address of &#39;Allocate&#39; stub into &#39;rax&#39; register and
  // call it.
  this.stub(&#39;rax&#39;, &#39;Allocate&#39;);

  this.Return();
}, { stubs: stubs });
</code></pre>
<p>As mentioned above, only stubs that were used during compilation process will
actually be generated and reused between all callers.</p>
<h2 id="heap">Heap</h2>
<p>With this knowledge, we can proceed to the memory allocation phase. But first,
lets take a short look at the structure and organization of the heap.</p>
<p>The <em>heap</em> is the place where JavaScript (and many other) VMs create and store
objects (usually, ones that can&#39;t be fit into CPU registers). Some heap objects
may contain references to other objects (in other words, can reference them).
All live objects and their references create a directed graph, starting at
so called <em>roots</em> (which are usually global variables and pointers on stack).</p>
<p>Although, it is usually used in VMs with JIT compilation, Garbage Collection is
not required for the Heap. Indeed, many VMs and languages choose to use
unmanaged memory instead (C/C++ as a banal example). In such cases you (as the
language user) will generally need to explicitly free unused resources to not
run out of the memory.</p>
<p>But for obvious reasons, the JavaScript subset compiler that we&#39;re implementing,
should support both managed memory and Garbage Collection (which will be
implemented later).</p>
<p>There are tons of books that may give you an advanced introduction into the
heap allocation and garbage collection (my recommendation is
<a href="http://www.amazon.com/The-Garbage-Collection-Handbook-Management/dp/1420082795/ref=sr_1_1?ie=UTF8&amp;qid=1383600127&amp;sr=8-1&amp;keywords=garbage+collection+handbook">The Garbage Collection Handbook</a>), and considerably many ways to allocate
and collect memory in the heap.</p>
<p>Usually, you will need to choose between the allocation speed and memory
fragmentation. But, since we are not covering this very deeply, I would
recommend to stick with the method called &quot;bump allocation&quot; for now.</p>
<h2 id="bump-allocation">Bump allocation</h2>
<p>Fixed-page bump allocation works in a following way.</p>
<ol>
<li>Take the memory chunk of fixed size (a <em>page</em>)</li>
<li>Give away consequent slices of it as a return value of the allocation
procedure.</li>
<li>When running low on memory, perform the Garbage Collection and free all
unused space, by either compacting live objects or evacuating them to the
new memory chunk (replacing references to live objects in both cases).</li>
</ol>
<p>In terms of <a href="https://github.com/indutny/jit.js">jit.js</a> and stubs API, this procedure may look as following:</p>
<pre><code class="lang-javascript">// Create fixed size memory chunk
var page = new Buffer(1024);

// Set-up pointers to page start and page end
var offset = jit.ptr(page);
var end = jit.ptr(page, page.length);

stubs.define(&#39;Alloc&#39;, function() {

  // Save &#39;rbx&#39; and &#39;rcx&#39; registers
  this.spill([&#39;rbx&#39;, &#39;rcx&#39;], function() {
    // Load `offset`
    //
    // NOTE: We&#39;ll use pointer to `offset` variable, to be able to update
    // it below
    this.mov(&#39;rax&#39;, this.ptr(offset));
    this.mov(&#39;rax&#39;, [&#39;rax&#39;]);

    // Load end
    //
    // NOTE: Same applies to end, though, we&#39;re not updating it right now
    this.mov(&#39;rbx&#39;, this.ptr(end));
    this.mov(&#39;rbx&#39;, [&#39;rbx&#39;]);

    // Calculate new `offset`
    this.mov(&#39;rcx&#39;, &#39;rax&#39;);

    // We&#39;ll assume that all allocations are 16 bytes = two 64bit pointers
    this.add(&#39;rcx&#39;, 16);

    // Check if we won&#39;t overflow our fixed size buffer
    this.cmp(&#39;rcx&#39;, &#39;rbx&#39;);

    // this.j() performs conditional jump to the specified label.
    // &#39;g&#39; stands for &#39;greater&#39;
    // &#39;overflow&#39; is a label name, bound below
    this.j(&#39;g&#39;, &#39;overflow&#39;);

    // Ok, we&#39;re good to go, update offset
    this.mov(&#39;rbx&#39;, this.ptr(offset));
    this.mov([&#39;rbx&#39;], &#39;rcx&#39;);

    // The first 64bit pointer is reserved for &#39;tag&#39;,
    // the second one is a `double` value
    this.mov([&#39;rax&#39;], 1);

    // Return &#39;rax&#39;
    this.Return();

    // Overflowed :(
    this.bind(&#39;overflow&#39;)

    // Invoke javascript function!
    // NOTE: This is really funky stuff, but I&#39;m not going to dive deep
    // into it right now
    this.runtime(function() {
      console.log(&#39;GC is needed, but not implemented&#39;);
    });

    // Crash
    this.int3();

    this.Return();
  });
});
</code></pre>
<p>That&#39;s it! Not totally straightforward, but not really complicated either!</p>
<p>This procedure will give away consequent slices of the <em>page</em>, and even tag
them! (I&#39;ll cover tagging in one of the next posts. Basically, they&#39;re used to
distinguish different kinds of heap objects).</p>
<p>Few things to note here:</p>
<ol>
<li><code>jit.ptr(buf, offset)</code> returns a <code>Buffer</code>, containing a pointer to the given
<code>buf</code> with <code>offset</code> added to it.</li>
<li><code>this.spill()</code> is a routine for saving and restoring registers to/from the
 memory (this process is usually called <em>spilling</em>). It takes list of the
 registers and the closure. These registers will be saved before entering the
 closure, and restored right after leaving it.
 NOTE: The restore code will be generated before each <code>this.Return()</code> too.</li>
<li><code>this.mov([&#39;rbx&#39;], &#39;rcx&#39;)</code> - stores <code>rcx</code> register into the memory location,
pointed by the value of <code>rbx</code> register.
NOTE: you can also specify an offset here: <code>this.mov([&#39;rbx&#39;, 8], &#39;rcx&#39;)</code>.</li>
<li>jit.js supports branching primitives: <code>this.cmp(a, b)</code>,
<code>this.j(condition, labelName)</code>, <code>this.j(labelName)</code>, <code>this.bind(labelName)</code>.</li>
</ol>
<h1 id="floating-point">Floating point</h1>
<p>Now as we have a <em>presumably</em> working allocation procedure, let&#39;s recall what
should be stored inside of this heap chunks. In the allocation procedure, we
create chunks with the 8 byte tag value, and the 8 byte contents. This is
enough to store <code>double</code> (as C type) floating point numbers.</p>
<p>There are plenty of assembly instructions to load/store/work with such numbers.
But note that to work with them - you&#39;ll need to store them in the different
register set: <code>xmm0</code>, <code>xmm1</code>, ... <code>xmm15</code>. Although, 64-bit floating numbers
could be stored in the general purpose registers: <code>rax</code>, <code>rbx</code>, ... Performing
math operations is possible only with a <code>xmm</code> register set. Here are some
instructions, that are present in <code>jit.js</code> and should be useful for our
compiler:</p>
<ol>
<li><code>movq(&#39;xmm&#39;, &#39;gp&#39;)</code> or <code>movq(&#39;gp&#39;, &#39;xmm&#39;)</code> to move 64bits from the general
purpose register (or memory pointed by it) to xmm, or the other way around.</li>
<li><code>movsd(&#39;xmm&#39;, &#39;xmm&#39;)</code> to move the value from one xmm to another.</li>
<li><code>addsd</code>, <code>mulsd</code>, <code>subsd</code>, <code>divsd</code> - addition, multiplication, subtraction,
division.</li>
<li><code>cvtsi2sd(&#39;xmm&#39;, &#39;gp&#39;)</code>, <code>cvts2si(&#39;gp&#39;, &#39;xmm&#39;)</code> - converts integer into
double, and double into integer, respectively.</li>
<li><code>roundsd(&#39;mode&#39;, &#39;xmm&#39;, &#39;xmm&#39;)</code> - round the <code>src</code> register using specified
<code>mode</code> (which is one of: <code>nearest</code>, <code>down</code>, <code>up</code>, <code>zero</code>) and place the
result into the <code>dst</code> register.</li>
</ol>
<p>Using this sacred knowledge we can patch our existing code to make it work with
the floating point numbers (yeah, we will remove the integer support for now):</p>
<pre><code class="lang-javascript">// Compile
var fn = jit.compile(function() {
  // This will generate default entry boilerplate
  this.Proc(function() {
    visit.call(this, ast);

    // The result should be in &#39;rax&#39; at this point
    //
    // This will generate default exit boilerplate
    this.Return();
  });
}, { stubs: stubs });

// Execute
console.log(fn());

function visit(ast) {
  if (ast.type === &#39;Program&#39;)
    visitProgram.call(this, ast);
  else if (ast.type === &#39;Literal&#39;)
    visitLiteral.call(this, ast);
  else if (ast.type === &#39;UnaryExpression&#39;)
    visitUnary.call(this, ast);
  else if (ast.type === &#39;BinaryExpression&#39;)
    visitBinary.call(this, ast);
  else
    throw new Error(&#39;Unknown ast node: &#39; + ast.type);
}

function visitProgram(ast) {
  assert.equal(ast.body.length,
               1,
               &#39;Only one statement programs are supported&#39;);
  assert.equal(ast.body[0].type, &#39;ExpressionStatement&#39;);

  // We&#39;ve a pointer in &#39;rax&#39;, convert it to integer
  visit.call(this, ast.body[0].expression);

  // Get floating point number out of heap number
  this.movq(&#39;xmm1&#39;, [&#39;rax&#39;, 8]);

  // Round it towards zero
  this.roundsd(&#39;zero&#39;, &#39;xmm1&#39;, &#39;xmm1&#39;);

  // Convert double to integer
  this.cvtsd2si(&#39;rax&#39;, &#39;xmm1&#39;);
}

function visitLiteral(ast) {
  assert.equal(typeof ast.value, &#39;number&#39;);

  // Allocate new heap number
  this.stub(&#39;rax&#39;, &#39;Alloc&#39;);

  // Save &#39;rbx&#39; register
  this.spill(&#39;rbx&#39;, function() {
    this.loadDouble(&#39;rbx&#39;, ast.value);
    this.mov([&#39;rax&#39;, 8], &#39;rbx&#39;);
  });
}

function visitBinary(ast) {
  // Preserve &#39;rbx&#39; after leaving the AST node
  this.spill(&#39;rbx&#39;, function() {
    // Visit right side of expresion
    visit.call(this, ast.right);

    // Move it to &#39;rbx&#39;
    this.mov(&#39;rbx&#39;, &#39;rax&#39;);

    // Visit left side of expression (the result is in &#39;rax&#39;)
    visit.call(this, ast.left);

    //
    // So, to conclude, we&#39;ve left side in &#39;rax&#39; and right in &#39;rbx&#39;
    //

    // Let&#39;s load their double values
    this.movq(&#39;xmm1&#39;, [&#39;rax&#39;, 8]);
    this.movq(&#39;xmm2&#39;, [&#39;rbx&#39;, 8]);

    // Execute binary operation
    if (ast.operator === &#39;+&#39;) {
      this.addsd(&#39;xmm1&#39;, &#39;xmm2&#39;);
    } else if (ast.operator === &#39;-&#39;) {
      this.subsd(&#39;xmm1&#39;, &#39;xmm2&#39;);
    } else if (ast.operator === &#39;*&#39;) {
      this.mulsd(&#39;xmm1&#39;, &#39;xmm2&#39;);
    } else if (ast.operator === &#39;/&#39;) {
      this.divsd(&#39;xmm1&#39;, &#39;xmm2&#39;);
    } else {
      throw new Error(&#39;Unsupported binary operator: &#39; + ast.operator);
    }

    // Allocate new number, and put value in it
    this.stub(&#39;rax&#39;, &#39;Alloc&#39;);
    this.movq([&#39;rax&#39;, 8], &#39;xmm1&#39;);
  });
}

function visitUnary(ast) {
  if (ast.operator === &#39;-&#39;) {
    // Negate argument by emulating binary expression
    visit.call(this, {
      type: &#39;BinaryExpression&#39;,
      operator: &#39;*&#39;,
      left: ast.argument,
      right: { type: &#39;Literal&#39;, value: -1 }
    })
  } else {
    throw new Error(&#39;Unsupported unary operator: &#39; + ast.operator);
  }
}
</code></pre>
<h2 id="to-be-continued">To be continued</h2>
<p>So, that&#39;s all I have to say to you for now. On a more social theme, you may
want subscribe to my <a href="https://twitter.com/indutny">twitter</a> or watch my <a href="https://github.com/indutny/blog">blog on github</a>. Don&#39;t miss
the next post!</p>

        </section>
      </article>
    </section>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    
      ga('create', 'UA-68572164-1', 'auto');
      ga('send', 'pageview');
    
    </script>
    <script src="https://vote.wdgt.io/cdn/snippet-v2.js" async></script>
  </body>
</html>
